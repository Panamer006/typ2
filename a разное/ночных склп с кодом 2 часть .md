ок! Кладу все патчи **текстом**. Скопируй содержимое каждого файла в проект (или слей с уже существующими), затем подправим по месту под ваши неймспейсы/обёртки ордеров.

---

# `typ_quantiles.mqh`

```mqh
// -----------------------------------------------------------------------------
// TYP2 Quantiles Loader (spread/ATR% by hour) — minimal implementation
// CSV: "quantiles.csv" в папке MQL5/Files/
// Columns: symbol,hour,spread_q80,atrpct_q20,atrpct_q80
// -----------------------------------------------------------------------------
#property strict
struct QRow { string sym; int hour; int spread_q80; double atrpct_q20; double atrpct_q80; };
QRow _QRows[];

bool TYPQ_Load(const string csvName="quantiles.csv"){
  int h = FileOpen(csvName, FILE_READ|FILE_CSV|FILE_ANSI, ',');
  if(h==INVALID_HANDLE){ Print("TYPQ_Load: cannot open ", csvName); return false; }
  ArrayResize(_QRows, 0);

  // попытка пропустить заголовок
  string a=FileReadString(h);
  if(StringToLower(a)!="symbol"){ FileSeek(h, 0, SEEK_SET); }
  else { for(int i=0;i<4;i++) FileReadString(h); }

  while(!FileIsEnding(h)){
    string sym=FileReadString(h); if(sym=="") break;
    int    hour  =(int)StrToInteger(FileReadString(h));
    int    sprq80=(int)StrToInteger(FileReadString(h));
    double aq20  =StrToDouble (FileReadString(h));
    double aq80  =StrToDouble (FileReadString(h));
    int n=ArraySize(_QRows); ArrayResize(_QRows,n+1);
    _QRows[n].sym=sym; _QRows[n].hour=hour; _QRows[n].spread_q80=sprq80;
    _QRows[n].atrpct_q20=aq20; _QRows[n].atrpct_q80=aq80;
  }
  FileClose(h);
  Print("TYPQ_Load: loaded ", ArraySize(_QRows), " rows.");
  return ArraySize(_QRows)>0;
}

bool __TYPQ_Find(const string sym, int hour, int &idxOut){
  for(int i=0;i<ArraySize(_QRows);++i)
    if(_QRows[i].sym==sym && _QRows[i].hour==hour){ idxOut=i; return true; }
  return false;
}

int TYPQ_SpreadQ80(const string sym, int hour, int fallbackPts){
  int idx; if(__TYPQ_Find(sym,hour,idx)) return _QRows[idx].spread_q80;
  return fallbackPts;
}

bool TYPQ_ATRPctRange(const string sym, int hour, double &lo, double &hi,
                      double fallbackLo, double fallbackHi){
  int idx; if(__TYPQ_Find(sym,hour,idx)){ lo=_QRows[idx].atrpct_q20; hi=_QRows[idx].atrpct_q80; return true; }
  lo=fallbackLo; hi=fallbackHi; return false;
}
```

---

# `patch_typ_core.mqh`

```mqh
// ==================== CORE: quantile guards + jitter + reason codes ====================
#property strict
#include "typ_quantiles.mqh"

enum TYP_REASON {
  RSN_NONE=0, RSN_NEWS, RSN_SPREAD, RSN_VOL, RSN_ROUTER, RSN_SERIES, RSN_EQUITY, RSN_COOLDOWN, RSN_CURRENCY
};

string ReasonToStr(TYP_REASON r){
  if(r==RSN_NEWS) return "news";
  if(r==RSN_SPREAD) return "spread";
  if(r==RSN_VOL) return "vol";
  if(r==RSN_ROUTER) return "router";
  if(r==RSN_SERIES) return "series";
  if(r==RSN_EQUITY) return "equity";
  if(r==RSN_COOLDOWN) return "cooldown";
  if(r==RSN_CURRENCY) return "currency";
  return "none";
}

void LOG_BLOCK(const string sym, const string bucket, const string sig, TYP_REASON reason, const string note=""){
  PrintFormat("BLOCK [%s] %s %s reason=%s %s", bucket, sym, sig, ReasonToStr(reason), note);
}
void LOG_OPEN(const string sym, const string bucket, const string sig, const string note=""){
  PrintFormat("OPEN  [%s] %s %s %s", bucket, sym, sig, note);
}

// -------- Quantile-aware Spread/Vol guards --------
class QSpreadGuard {
  int m_fallbackPts;
public:
  void Init(int fallbackPts){ m_fallbackPts=fallbackPts; }
  bool Ok(const string sym){
    MqlDateTime dt; TimeToStruct(TimeCurrent(), dt);
    int thr = TYPQ_SpreadQ80(sym, dt.hour, m_fallbackPts);

    double sprPts;
    if(!SymbolInfoInteger(sym, SYMBOL_SPREAD_FLOAT)){
      sprPts = (double)SymbolInfoInteger(sym, SYMBOL_SPREAD);
    } else {
      double ask=SymbolInfoDouble(sym, SYMBOL_ASK), bid=SymbolInfoDouble(sym, SYMBOL_BID);
      double pt = SymbolInfoDouble(sym, SYMBOL_POINT);
      sprPts = (ask-bid)/pt;
    }
    return sprPts>0 && sprPts <= thr;
  }
};

class QVolatilityGate {
  double m_fallbackLo, m_fallbackHi; int m_atrPeriod; ENUM_TIMEFRAMES m_tf;
public:
  void Init(double loPct, double hiPct, int atrPeriod=14, ENUM_TIMEFRAMES tf=PERIOD_M15){
    m_fallbackLo=loPct; m_fallbackHi=hiPct; m_atrPeriod=atrPeriod; m_tf=tf;
  }
  bool Ok(const string sym){
    // ATR%
    int h=iATR(sym, m_tf, m_atrPeriod);
    if(h==INVALID_HANDLE) return false;
    double b[]; if(CopyBuffer(h,0,0,1,b)<=0){ IndicatorRelease(h); return false; }
    double atr=b[0]; IndicatorRelease(h);
    double px=iClose(sym, m_tf, 0); if(atr<=0 || px<=0) return false;
    double pct=100.0*atr/px;

    MqlDateTime dt; TimeToStruct(TimeCurrent(), dt);
    double lo,hi; TYPQ_ATRPctRange(sym, dt.hour, lo, hi, m_fallbackLo, m_fallbackHi);
    return pct>=lo && pct<=hi;
  }
};

// -------- Jitter очередь на отложенные открытия (анти-синхрон) --------
struct JitterItem { string sym; datetime due; string bucket; string sig; int dir; double sl; double tp; };
JitterItem _JitQ[];

void JitterSchedule(const string sym, const string bucket, const string sig,
                    int dir, double sl, double tp, int minSec=3, int maxSec=15){
  int n=ArraySize(_JitQ); ArrayResize(_JitQ,n+1);
  int jitter=(minSec<maxSec)? (minSec + (int)MathRand()%(maxSec-minSec+1)) : minSec;
  _JitQ[n].sym=sym; _JitQ[n].bucket=bucket; _JitQ[n].sig=sig;
  _JitQ[n].dir=dir; _JitQ[n].sl=sl; _JitQ[n].tp=tp;
  _JitQ[n].due=TimeCurrent()+jitter;
}

bool JitterPopDue(int &idxOut){
  datetime now=TimeCurrent();
  for(int i=0;i<ArraySize(_JitQ);++i) if(_JitQ[i].due<=now){ idxOut=i; return true; }
  return false;
}
void JitterErase(int idx){
  if(idx<0 || idx>=ArraySize(_JitQ)) return;
  for(int i=idx;i<ArraySize(_JitQ)-1;i++) _JitQ[i]=_JitQ[i+1];
  ArrayResize(_JitQ, ArraySize(_JitQ)-1);
}
```

---

# `patch_typ_strategies.mqh`

```mqh
// ==================== STRATEGIES: Night MR (slope+BB out→in) & Night Scalp (QuietRange+stop-limit) ====================
#property strict

enum TYP_DIR { DIR_NONE=0, DIR_LONG=1, DIR_SHORT=-1 };

struct TYP_SignalEx {
  bool valid; string id,symbol,bucket,reason;
  int dir; double entry, sl, tp1, tp2, tp3; datetime expiry; double strength;
  // stop-limit extras (для скальпа)
  bool use_stop_limit; double stop_price;
};

// --- обёртки индикаторов (MQL5: iXXX -> handle -> CopyBuffer) ---
double __S_ATR(const string s, ENUM_TIMEFRAMES tf, int p){
  int h=iATR(s, tf, p); if(h==INVALID_HANDLE) return 0.0;
  double b[]; if(CopyBuffer(h,0,0,1,b)<=0){ IndicatorRelease(h); return 0.0; }
  IndicatorRelease(h); return b[0];
}
double __S_EMA(const string s, ENUM_TIMEFRAMES tf, int p){
  int h=iMA(s, tf, p, 0, MODE_EMA, PRICE_CLOSE); if(h==INVALID_HANDLE) return 0.0;
  double b[]; if(CopyBuffer(h,0,0,1,b)<=0){ IndicatorRelease(h); return 0.0; }
  IndicatorRelease(h); return b[0];
}
double __S_EMA_shift(const string s, ENUM_TIMEFRAMES tf, int p, int shift){
  int h=iMA(s, tf, p, 0, MODE_EMA, PRICE_CLOSE); if(h==INVALID_HANDLE) return 0.0;
  double b[]; if(CopyBuffer(h,0,shift,1,b)<=0){ IndicatorRelease(h); return 0.0; }
  IndicatorRelease(h); return b[0];
}
double __S_ADX(const string s, ENUM_TIMEFRAMES tf, int p){
  int h=iADX(s, tf, p); if(h==INVALID_HANDLE) return 0.0; // buffer 0 = ADX
  double b[]; if(CopyBuffer(h,0,0,1,b)<=0){ IndicatorRelease(h); return 0.0; }
  IndicatorRelease(h); return b[0];
}
double __S_STD(const string s, ENUM_TIMEFRAMES tf, int p){
  double mean=__S_EMA(s,tf,p), sum=0; if(mean==0) return 0;
  for(int i=0;i<p;i++){ double x=iClose(s,tf,i)-mean; sum+=x*x; }
  return MathSqrt(sum/MathMax(1,p-1));
}
double __S_EMA_Slope(const string s, ENUM_TIMEFRAMES tf, int p){
  double e0=__S_EMA(s,tf,p), e1=__S_EMA_shift(s,tf,p,1);
  double pt=SymbolInfoDouble(s,SYMBOL_POINT);
  return (pt>0) ? (e0-e1)/pt : 0.0;
}

bool __S_OutThenIn_BB(const string s, ENUM_TIMEFRAMES tf, int p, double k){
  double ma=__S_EMA(s,tf,p), sd=__S_STD(s,tf,p);
  if(sd<=0) return false;
  double up=ma+k*sd, dn=ma-k*sd;
  double c0=iClose(s,tf,0), c1=iClose(s,tf,1);
  bool prev_out=(c1>up || c1<dn);
  bool now_in  =(c0<=up && c0>=dn);
  return (prev_out && now_in);
}

bool __S_QuietRange(const string s, ENUM_TIMEFRAMES tf, int N, double kATR){
  double atr=__S_ATR(s,tf,14); if(atr<=0) return false;
  double hi=-DBL_MAX, lo=DBL_MAX;
  for(int i=0;i<N;i++){ hi=MathMax(hi,iHigh(s,tf,i)); lo=MathMin(lo,iLow(s,tf,i)); }
  double range=hi-lo;
  return range <= kATR*atr;
}

// -------- Night MR (улучшенный): slope-veto + Bollinger out→in  --------
TYP_SignalEx BuildNightMR_Improved(const string s, ENUM_TIMEFRAMES tf){
  TYP_SignalEx z; ZeroMemory(z); z.symbol=s; z.bucket="FX_Night_MR"; z.id="night_mr_v2";
  double atr=__S_ATR(s,tf,14); if(atr<=0) return z;
  double ema=__S_EMA(s,tf,50); double px=iClose(s,tf,0);
  double zscore=(px-ema)/atr;

  // veto: трендовость/наклон
  double slope=MathAbs(__S_EMA_Slope(s,tf,50));
  double adx=__S_ADX(s,tf,14);
  if(slope>0.6 && adx>18) return z; // TODO: калибровка

  // подтверждение: вышли за полосу -> вернулись внутрь
  if(!__S_OutThenIn_BB(s,tf,50,1.6)) return z; // TODO: калибровка

  if(zscore<-0.8){ z.dir=DIR_LONG;  z.entry=px; z.sl=px-1.2*atr; z.tp1=ema; z.valid=true; z.reason="MR z<-0.8 / slope&BB ok"; }
  if(zscore>+0.8){ z.dir=DIR_SHORT; z.entry=px; z.sl=px+1.2*atr; z.tp1=ema; z.valid=true; z.reason="MR z>+0.8 / slope&BB ok"; }
  z.expiry=TimeCurrent()+60*30;
  return z;
}

// -------- Night Scalp (улучшенный): QuietRange + stop-limit к EMA34 --------
TYP_SignalEx BuildNightScalp_Improved(const string s, ENUM_TIMEFRAMES tf){
  TYP_SignalEx z; ZeroMemory(z); z.symbol=s; z.bucket="FX_Night_Scalp"; z.id="night_scalp_v2";
  if(!__S_QuietRange(s,tf,6,0.9)) return z;    // N=6 баров в диапазоне <=0.9*ATR
  double atr=__S_ATR(s,tf,14); if(atr<=0) return z;
  double ema=__S_EMA(s,tf,34); double px=iClose(s,tf,0);

  z.use_stop_limit=true;
  if(px<ema){ // ждём возврат вверх к EMA
    z.dir=DIR_LONG;  z.stop_price=ema; z.sl=px-0.8*atr; z.tp1=px+0.8*atr; z.valid=true; z.reason="Scalp quiet→EMA34";
  } else {
    z.dir=DIR_SHORT; z.stop_price=ema; z.sl=px+0.8*atr; z.tp1=px-0.8*atr; z.valid=true; z.reason="Scalp quiet→EMA34";
  }
  z.expiry=TimeCurrent()+60*20;
  return z;
}
```

---

# `patch_typ_risk.mqh`

```mqh
// ==================== RISK: session kill-switch, currency cap, cooldown ====================
#property strict

// ---- Kill-switch на профиль (до конца сессии) ----
struct BucketState { string name; bool disabledUntilSessionEnd; datetime sessionEnd; };
BucketState _Buckets[];

void BucketRegister(const string name){
  for(int i=0;i<ArraySize(_Buckets);++i) if(_Buckets[i].name==name) return;
  int n=ArraySize(_Buckets); ArrayResize(_Buckets,n+1);
  _Buckets[n].name=name; _Buckets[n].disabledUntilSessionEnd=false; _Buckets[n].sessionEnd=0;
}
void BucketDisableUntilEnd(const string name, datetime sessionEnd){
  for(int i=0;i<ArraySize(_Buckets);++i)
    if(_Buckets[i].name==name){ _Buckets[i].disabledUntilSessionEnd=true; _Buckets[i].sessionEnd=sessionEnd; break; }
}
bool BucketAllowed(const string name){
  for(int i=0;i<ArraySize(_Buckets);++i)
    if(_Buckets[i].name==name){
      if(_Buckets[i].disabledUntilSessionEnd){
        if(TimeCurrent() >= _Buckets[i].sessionEnd){ _Buckets[i].disabledUntilSessionEnd=false; return true; }
        return false;
      }
      return true;
    }
  return true;
}

// ---- Ограничение экспозиции по базовой валюте ----
int CurrencyActivePositions(const string base3){
  int n=0;
  for(int i=PositionsTotal()-1;i>=0;--i){
    if(!PositionSelectByIndex(i)) continue;
    string s=PositionGetString(POSITION_SYMBOL);
    if(StringLen(s)>=6){
      string b=StringSubstr(s,0,3);
      if(b==base3) ++n;
    }
  }
  return n;
}
bool CurrencyExposureAllow(const string sym, int maxPerBase){
  if(StringLen(sym)<6) return true;
  string base3=StringSubstr(sym,0,3);
  return CurrencyActivePositions(base3) < maxPerBase;
}

// ---- Cooldown по символу (анти-переоткрытие) ----
struct CooldownRow { string sym; datetime last; };
CooldownRow _CDs[];

void CooldownNote(const string sym){
  for(int i=0;i<ArraySize(_CDs);++i) if(_CDs[i].sym==sym){ _CDs[i].last=TimeCurrent(); return; }
  int n=ArraySize(_CDs); ArrayResize(_CDs,n+1); _CDs[n].sym=sym; _CDs[n].last=TimeCurrent();
}
bool CooldownAllow(const string sym, int minutes){
  for(int i=0;i<ArraySize(_CDs);++i) if(_CDs[i].sym==sym)
    return (TimeCurrent()-_CDs[i].last) >= (minutes*60);
  return true;
}
```

---

# `patch_TakeYourProfit2.mq5`

```mq5
// ==================== GLUE: quantile guards, improved signals, jitter & stop-limit ====================
#property strict
#include "patch_typ_core.mqh"
#include "patch_typ_strategies.mqh"
#include "patch_typ_risk.mqh"

QSpreadGuard   GQSpread;
QVolatilityGate GQVol;

// Пример: вызвать в OnInit()
int OnInit(){
  MathSrand((uint)TimeLocal());
  TYPQ_Load("quantiles.csv");        // загрузить квантили (есть fallback)
  GQSpread.Init(20);                 // запасной порог спреда (points)
  GQVol.Init(0.15, 1.20, 14, PERIOD_M15); // ATR% коридор (fallback)
  BucketRegister("FX_Night_MR");
  BucketRegister("FX_Night_Scalp");
  return(INIT_SUCCEEDED);
}

// Вызови из своего блока сессии/нового бара (например, 19:00–23:00)
void ProcessNightProfiles(){
  string mrList[];  StringSplit("EURGBP,AUDNZD,AUDCAD,NZDCAD", ',', mrList);
  string scList[];  StringSplit("EURUSD,GBPUSD,USDCHF",       ',', scList);

  // --- Night MR ---
  for(int i=0;i<ArraySize(mrList);++i){
    string s = StringTrim(mrList[i]);
    if(!SymbolSelect(s,true)) continue;

    if(!BucketAllowed("FX_Night_MR")){ LOG_BLOCK(s,"FX_Night_MR","night_mr_v2",RSN_EQUITY,"bucket disabled"); continue; }
    if(!GQSpread.Ok(s))               { LOG_BLOCK(s,"FX_Night_MR","night_mr_v2",RSN_SPREAD,"quantile"); continue; }
    if(!GQVol.Ok(s))                  { LOG_BLOCK(s,"FX_Night_MR","night_mr_v2",RSN_VOL,"quantile");    continue; }
    if(!CooldownAllow(s,30))          { LOG_BLOCK(s,"FX_Night_MR","night_mr_v2",RSN_COOLDOWN,"30m");    continue; }
    if(!CurrencyExposureAllow(s,2))   { LOG_BLOCK(s,"FX_Night_MR","night_mr_v2",RSN_CURRENCY,"base cap"); continue; }

    TYP_SignalEx sig = BuildNightMR_Improved(s, PERIOD_M15);
    if(!sig.valid) continue;

    // откладываем открытие (джиттер) — чтобы не входить всем «стадом»
    JitterSchedule(s, "FX_Night_MR", sig.id, sig.dir, sig.sl, sig.tp1, 3, 12);
  }

  // --- Night Scalp ---
  for(int j=0;j<ArraySize(scList);++j){
    string s = StringTrim(scList[j]);
    if(!SymbolSelect(s,true)) continue;

    if(!BucketAllowed("FX_Night_Scalp")){ LOG_BLOCK(s,"FX_Night_Scalp","night_scalp_v2",RSN_EQUITY,"bucket disabled"); continue; }
    if(!GQSpread.Ok(s))                 { LOG_BLOCK(s,"FX_Night_Scalp","night_scalp_v2",RSN_SPREAD,"quantile"); continue; }
    if(!GQVol.Ok(s))                    { LOG_BLOCK(s,"FX_Night_Scalp","night_scalp_v2",RSN_VOL,"quantile");    continue; }
    if(!CooldownAllow(s,20))            { LOG_BLOCK(s,"FX_Night_Scalp","night_scalp_v2",RSN_COOLDOWN,"20m");    continue; }
    if(!CurrencyExposureAllow(s,2))     { LOG_BLOCK(s,"FX_Night_Scalp","night_scalp_v2",RSN_CURRENCY,"base cap"); continue; }

    TYP_SignalEx sig = BuildNightScalp_Improved(s, PERIOD_M15);
    if(!sig.valid) continue;

    if(sig.use_stop_limit){
      // Здесь лучше оформлять BuyStop/SellStop по sig.stop_price + expiry-контроль
      // Для простоты — тоже через джиттер (в боевом коде интегрируйте pending-ордера)
      JitterSchedule(s, "FX_Night_Scalp", sig.id, sig.dir, sig.sl, sig.tp1, 3, 12);
    } else {
      JitterSchedule(s, "FX_Night_Scalp", sig.id, sig.dir, sig.sl, sig.tp1, 3, 12);
    }
  }
}

// Вызови часто (OnTick/OnTimer) — отправляет сделки, чей jitter-таймер истёк
void ProcessJitterQueue(){
  int idx;
  while(JitterPopDue(idx)){
    string s=_JitQ[idx].sym; int dir=_JitQ[idx].dir;
    double sl=_JitQ[idx].sl, tp=_JitQ[idx].tp;
    double vol=0.01; bool ok=false;

    if(dir>0) ok = TYPTrade.Buy(vol, s, 0.0, sl, tp);
    if(dir<0) ok = TYPTrade.Sell(vol, s, 0.0, sl, tp);

    if(ok){ LOG_OPEN(s, _JitQ[idx].bucket, _JitQ[idx].sig, "jitter"); CooldownNote(s); }
    JitterErase(idx);
  }
}
```

---

# `README_Night_Upgrades.md`

```md
# TYP2 — Night Profiles Upgrades (H-priority)

## Состав
1. `typ_quantiles.mqh` — загрузчик квантили по часу (спред/ATR%). CSV: `MQL5/Files/quantiles.csv`.
2. `patch_typ_core.mqh` — квантилированные гварды (Spread/Vol), jitter-очередь, reason codes.
3. `patch_typ_strategies.mqh` — Night MR (slope-veto + Bollinger out→in), Night Scalp (QuietRange + stop-limit).
4. `patch_typ_risk.mqh` — kill-switch по сессии, currency cap, cooldown символа.
5. `patch_TakeYourProfit2.mq5` — пример склейки.

## Подключение
- Скопировать `.mqh` файлы в Include (или рядом с вашими `typ_*.mqh`) и/или слить с существующими модулями.
- Положить `quantiles.csv` в `MQL5/Files/`. Заполнить по брокеру: `symbol,hour,spread_q80,atrpct_q20,atrpct_q80`.
- В основном ЕА вызывать:
  - `ProcessNightProfiles()` в окне сессии,
  - `ProcessJitterQueue()` часто (OnTick/OnTimer).

## Что смотреть в логах
- `BLOCK [bucket] <sym> <sig> reason=spread/vol/router/cooldown/currency`
- `OPEN  [bucket] <sym> <sig> jitter`

## Цели
- Частота входов −15…−30% без потери PF.
- MR: win-rate +5–10 п.п.; Scalp: стабильность TP≈1R ↑.
- Меньше синхронных открытий между символами.
```

---

# `quantiles.csv` (шаблон; положить в `MQL5/Files/`)

```
symbol,hour,spread_q80,atrpct_q20,atrpct_q80
EURGBP,19,12,0.10,0.60
EURGBP,20,12,0.10,0.60
EURGBP,21,12,0.10,0.60
AUDNZD,19,18,0.12,0.80
AUDNZD,20,18,0.12,0.80
AUDNZD,21,18,0.12,0.80
EURUSD,20,10,0.08,0.55
GBPUSD,20,12,0.09,0.60
USDCHF,20,12,0.08,0.55
```

---

## Как запускать (минимально)

1. В `OnInit()` — `TYPQ_Load("quantiles.csv")`, инициализируй `GQSpread`/`GQVol`, зарегистрируй бакеты.
2. В обработчике «нового бара» в вечернем окне — `ProcessNightProfiles();`
3. В `OnTick()` или `OnTimer()` — `ProcessJitterQueue();`

Если где-то «не сойдутся» сигнатуры (у вас свои трейд-обёртки/логгеры) — скажи, подгоню под ваш каркас прямо здесь.

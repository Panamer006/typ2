# Техническое Задание (ТЗ) для Задачи: СПРИНТ 2 - Ночной Двигатель и Контекст

## 1. Цель

Реализовать полноценные торговые "двигатели" для торговли во флэте, а также создать мощную систему технического анализа ("Глаза Советника"), способную распознавать и интерпретировать ключевые рыночные паттерны. Вся новая логика должна быть интегрирована через Resolver с учетом утвержденной иерархии сигналов.

## 2. Пошаговый План Реализации

### **Часть А: "Глаза Советника" (Библиотеки ТА)**

#### **Задача 1: Реализация Библиотеки Свечных Паттернов (	yp_patterns.mqh)**

1.  **Действие:** В классе CPatterns реализуйте полную логику для **всех 10 "критически важных" паттернов**, утвержденных ранее:
    *   IsBullishEngulfing, IsBearishEngulfing (Поглощение)
    *   IsPinBar (Пин-бар, с определением бычьего/медвежьего контекста)
    *   IsMorningStar, IsEveningStar (Звезды)
    *   IsThreeWhiteSoldiers, IsThreeBlackCrows (Три Солдата/Вороны)
    *   IsPiercingLine, IsDarkCloudCover (Просвет / Завеса)
    *   IsHarami (Харами)
    *   IsTweezerTopBottom (Пинцет)
    *   IsThreeInsideUpDown (Три Внутри)
    *   IsRailwayTracks (Рельсы)
2.  **Действие:** Каждый метод детекции должен принимать const MqlRates &rates[] и int shift и возвращать 	rue/false.
3.  **Действие:** Создайте публичный метод oid DrawPattern(...), который будет отвечать за **"Визуальный Слой"**: отрисовку рамок, иконок и меток на графике для каждого обнаруженного паттерна.

#### **Задача 2: Реализация Библиотеки Фигур ТА (	yp_figures.mqh)**

1.  **Действие:** В классе CFigures реализуйте детекторы для **всех 6 "критически важных" фигур**:
    *   DetectHeadAndShoulders (Голова и Плечи)
    *   DetectDoubleTopBottom (Двойная Вершина/Дно)
    *   DetectWedge (Клин)
    *   DetectFlag (Флаг)
    *   DetectTriangle (Треугольник)
    *   DetectRectangle (Прямоугольник)
2.  **Действие:** Каждый метод детекции должен возвращать структуру с полным описанием фигуры (координаты ключевых точек, статус "сформирована/пробита", цели и т.д.).
3.  **Действие:** Создайте публичный метод oid DrawFigure(...), который будет отрисовывать на графике все элементы фигуры: линии, цели, метки.

### **Часть Б: "Двигатели для Флэта" (	yp_strategies.mqh)**

#### **Задача 3: Реализация Стратегии CStrategy_ChannelBoundary**

1.  **Действие:** Создайте в файле 	yp_strategies.mqh новый класс CStrategy_ChannelBoundary.
2.  **Действие:** Реализуйте метод SignalCandidate GetSignal().
    *   **Логика:**
        1.  Используйте Канал Дончиана или Канал Кельтнера для определения границ флэта.
        2.  При касании ценой верхней границы генерируйте SignalCandidate на продажу.
        3.  **Тип ордера:** ORDER_TYPE_SELL_LIMIT.
        4.  **SL:** За границей канала (на расстоянии X * ATR).
        5.  **TP:** У средней линии или противоположной границы канала.

#### **Задача 4: Реализация Стратегии CStrategy_FalseBreakout**

1.  **Действие:** Создайте в файле 	yp_strategies.mqh новый класс CStrategy_FalseBreakout.
2.  **Действие:** Реализуйте метод SignalCandidate GetSignal().
    *   **Логика:**
        1.  Определите ключевой диапазон (например, High/Low Азиатской сессии).
        2.  Дождитесь пробоя этого диапазона.
        3.  Если цена в течение N свечей не может закрепиться и возвращается обратно в диапазон, генерируйте SignalCandidate против ложного пробоя.
        4.  **Тип ордера:** ORDER_TYPE_BUY/SELL (по рынку).
        5.  **SL:** За экстремумом ложного пробоя.
        6.  **TP:** У противоположной границы диапазона.

#### **Задача 5: Усиление Стратегии CStrategy_NightMR**

1.  **Действие:** В классе CStrategy_NightMR реализуйте полную логику скоринга в методе GetSignal().
    *   **Логика:**
        1.  **"Якорь":** Убедитесь, что цена коснулась 2-й границы Боллинджера.
        2.  **Скоринг:** Последовательно вызывайте методы из CPatterns, CFigures и других модулей для проверки **всех 12 "критически важных" подтверждений**, которые мы утвердили (от VWAP до "Штрафа за отсутствие дивергенции"). Начисляйте/вычитайте очки.
        3.  **Формирование SignalCandidate:** Если итоговый score > 80, сформируйте и верните SignalCandidate.

### **Часть В: "Мозг" (	yp_resolver.mqh)**

#### **Задача 6: Реализация Иерархической Логики в Resolver-е**

1.  **Действие:** Создайте новый файл Experts/TYP2/Modules/typ_resolver.mqh и класс CResolver.
2.  **Действие:** Реализуйте главный метод TradeOrderInstruction Decide(SignalCandidate[] candidates).
    *   **Логика:**
        1.  **Иерархия:** В первую очередь ищите сигналы Уровня 1 (Макро-Фигуры от CFigures). Если такая фигура найдена, она устанавливает глобальный "сценарий" и отфильтровывает все сигналы-кандидаты, идущие против нее.
        2.  **Скоринг и Конфлюэнс:** Оцените оставшиеся кандидаты. Если несколько сигналов (например, от NightMR и ChannelBoundary) указывают в одну сторону, умножьте их score на коэффициент конфлюэнса.
        3.  **Выбор Лучшего:** Выберите кандидата с наивысшим итоговым score.
        4.  **Формирование Торгового Приказа:** На основе лучшего кандидата и его score, сформируйте и верните TradeOrderInstruction, указав **тип ордера**, **сценарий управления объемом** и **цены SL/TP**, как мы обсуждали.

### **Задача 7: Интеграция в TakeYourProfit2.mq5**

1.  **Действие:** Подключите все новые модули. Создайте глобальные экземпляры всех новых классов (CResolver, CStrategy_... и т.д.).
2.  **Действие:** В OnInit() вызовите их инициализацию.
3.  **Действие:** В OnTick(), в блоке генерации сигналов:
    1.  Создайте массив SignalCandidate.
    2.  Вызовите GetSignal() для **каждого** активного "двигателя" (NightMR, ChannelBoundary и т.д.) и добавьте их кандидатов в массив.
    3.  Передайте этот массив в g_Resolver.Decide().
    4.  Если esolver_instruction.isValid — 	rue, передайте этот "приказ" в торговый движок для исполнения.

# Техническое Задание (ТЗ) для Задачи: T2-REFACTOR-SPRINT1

## 1. Цель

Провести рефакторинг и "чистку" кода, созданного в рамках Спринта 1 (Regime Engine, Risk Manager, ExecGate), для устранения "технического долга", улучшения читаемости, гибкости и производительности.

## 2. Пошаговый План Реализации

### **Задача 1: Рефакторинг 	yp_regime_engine.mqh**

1.  **Действие: Устранение "Магических Чисел".**
    *   **Где:** В классе CRegimeEngine.
    *   **Что сделать:** Все пороговые значения индикаторов (22, 38, 18, 62, 40 и т.д.) должны быть вынесены в private-переменные класса (например, m_adx_trend_threshold, m_chop_flat_threshold).
    *   **Как сделать:** Инициализируйте эти переменные в конструкторе класса. В дальнейшем мы сможем легко передавать их через input-параметры.

2.  **Действие: Добавление "Заглушек" для Вспомогательных Функций.**
    *   **Где:** В классе CRegimeEngine.
    *   **Что сделать:** Убедитесь, что все вспомогательные функции, упомянутые в ТЗ, но еще не реализованные, существуют в виде "заглушек".
    *   **Как сделать:**
        `cpp
        private:
            double GetIndicatorValue(int handle, int buffer, int shift) { return 0.0; }
            double CalculateZScore(double value, ... ) { return 0.0; }
            bool IsMarketCrashing(string ticker, ...) { return false; }
            bool HasDivergence(...) { return false; }
        `

3.  **Действие: Создание Полного Списка Хэндлов Индикаторов.**
    *   **Где:** В private-секции класса CRegimeEngine и в методе Initialize.
    *   **Что сделать:** Добавьте переменные и инициализацию хэндлов для **всех** индикаторов, которые мы утвердили: Choppiness Index, Donchian Channel, Normalized Volume, RSI, MACD.
    *   **Как сделать:**
        `cpp
        private:
            int m_h_adx;
            int m_h_chop;
            // ... и т.д.
        public:
            void Initialize(...) {
                m_h_adx = iADX(...);
                m_h_chop = iCustom(..., "ChoppinessIndex", ...);
                // ... и т.д.
            }
        `

### **Задача 2: Рефакторинг 	yp_risk.mqh**

1.  **Действие: Улучшение Хранения Состояния по Символам.**
    *   **Где:** В классе CRiskManager, переменная m_symbol_states_map.
    *   **Что сделать:** Текущая реализация, скорее всего, использует CArrayObj. Это приемлемо, но не оптимально. Давайте сразу заложим более производительную архитектуру.
    *   **Как сделать:** Замените CArrayObj* m_symbol_states_map на стандартную библиотеку CHashMap (если доступна) или создайте простую реализацию хеш-таблицы для хранения пар "символ" -> "указатель на SymbolState". Это даст нам доступ к состоянию символа за O(1) вместо O(n). Если это слишком сложно для Cursor-а, оставьте CArrayObj, но добавьте комментарий // TODO: Optimize symbol state storage using a hash map..

2.  **Действие: Реализация "Заглушки" для ParentalLock.**
    *   **Где:** В 	yp_execfilters.mqh, так как этот гвард срабатывает "на входе".
    *   **Что сделать:** Создайте в классе CExecGate метод ool IsParentalLockOK(string &reason).
    *   **Как сделать:** Внутри метода пока просто eturn true;. Добавьте комментарий // TODO: Implement full ParentalLock logic using OnTradeTransaction event.. Интегрируйте вызов этого метода в главный гвард IsExecutionAllowed.

### **Задача 3: Общий Рефакторинг (для всех файлов Спринта 1)**

1.  **Действие: Добавление Комментариев.**
    *   **Где:** Все новые классы и методы в 	yp_regime_engine.mqh, 	yp_risk.mqh, 	yp_execfilters.mqh.
    *   **Что сделать:** Попросите Cursor пройтись по всему коду и добавить осмысленные комментарии в стиле Doxygen. Каждый метод должен иметь краткое описание того, что он делает, какие параметры принимает и что возвращает.

2.  **Действие: Проверка на const-корректность.**
    *   **Где:** Все новые методы.
    *   **Что сделать:** Методы, которые не изменяют состояние класса (например, геттеры или простые проверки), должны быть помечены как const.
    *   **Пример:** E_MarketRegime GetCurrentRegime() const;

3.  **Действие: Проверка Освобождения Ресурсов.**
    *   **Где:** Деструкторы (~CRegimeEngine, ~CRiskManager и т.д.).
    *   **Что сделать:** Убедитесь, что все хэндлы индикаторов, созданные в Initialize, корректно освобождаются с помощью IndicatorRelease(). Убедитесь, что все динамически созданные объекты (например, m_symbol_states_map) корректно удаляются.

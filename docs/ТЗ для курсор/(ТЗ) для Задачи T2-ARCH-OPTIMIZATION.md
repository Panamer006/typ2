# Техническое Задание (ТЗ) для Задачи: T2-ARCH-OPTIMIZATION

## 1. Цель

Провести архитектурную оптимизацию существующей кодовой базы для повышения производительности, надежности и масштабируемости, реализовав три ключевых улучшения: "Дросселирование вычислений", "Синхронизацию состояния" и подготовку к "Движку Правил".

## 2. Пошаговый План Реализации

### **Задача 1: Реализация "Дросселирования Вычислений" (Throttling)**

1.  **Действие:** Создайте новый, простой модуль `typ_timer_manager.mqh` с классом `CTimerManager`.
    *   **Логика:** Этот класс будет отслеживать время и на каждом тике сообщать, наступило ли время для выполнения той или иной задачи.
    *   **Пример методов:** `bool IsNewBar(ENUM_TIMEFRAMES tf)`, `bool IsSecondElapsed(int seconds)`.

2.  **Действие:** Модифицируйте главный файл `TakeYourProfit2.mq5`.
    *   **Что сделать:** В `OnTick()` оберните "тяжелые" вызовы в проверки из `CTimerManager`.
    *   **"Принцип Синхронизации с Таймфреймом":**
        ```cpp
        // --- В OnTick() ---
        g_TimerManager.OnTick(); // Обновляем таймеры

        // --- Блок Детекции Фигур ТА (Уровень 1 и 2) ---
        if (g_TimerManager.IsNewBar(PERIOD_H1)) { // Проверяем фигуры только на новом часовом баре
            g_Figures.DetectAll(); 
        }

        // --- Блок Детекции Свечных Паттернов (Уровень 3) ---
        if (g_TimerManager.IsNewBar(PERIOD_M15)) { // Проверяем паттерны только на новом M15 баре
            g_Patterns.DetectAll();
        }

        // --- Блок Генерации Сигналов и Резолвера ---
        // Его можно оставить на каждом тике или дросселировать до 1-5 секунд
        if (g_TimerManager.IsSecondElapsed(5)) {
            // ... (сбор кандидатов и вызов Resolver-а)
        }
        ```

### **Задача 2: Реализация "Синхронизации Состояния" в `Position Manager`**

1.  **Действие:** Модифицируйте класс `CPositionManager` в `typ_position_manager.mqh`.
    *   **Что сделать:** Добавьте новый публичный метод `void SynchronizeState()`.
    *   **Логика метода:**
        1.  Пройтись циклом по всем реальным открытым позициям у брокера (`PositionsTotal()`).
        2.  Для каждой реальной позиции проверить, есть ли она в нашем внутреннем списке `m_managed_positions`.
        3.  **Если нет:** Добавить ее в список как "внешнюю" или "неуправляемую" позицию.
        4.  Пройтись по нашему внутреннему списку `m_managed_positions`.
        5.  Для каждой нашей позиции проверить, существует ли она еще у брокера.
        6.  **Если нет:** Удалить ее из нашего списка, так как она была закрыта (возможно, вручную или по стопу/тейку).

2.  **Действие:** Модифицируйте главный файл `TakeYourProfit2.mq5`.
    *   **Что сделать:** В `OnInit()`, сразу после инициализации `g_PosManager`, вызовите `g_PosManager.SynchronizeState();`. Это гарантирует, что при перезапуске советника он сразу "подхватит" все уже открытые им сделки.
    *   (Опционально) Добавьте периодический вызов `SynchronizeState()` в `OnTick()` раз в час для дополнительной надежности.

### **Задача 3: Подготовка к "Движку Правил" в `Resolver`-е**

1.  **Действие:** Модифицируйте класс `CResolver` в `typ_resolver.mqh`.
    *   **Что сделать:** На данном этапе мы не будем реализовывать полный "Движок Правил", но заложим для него основу.
    *   **Как сделать:**
        1.  Создайте базовый класс/интерфейс `IRule`. У него будет один виртуальный метод `double Apply(SignalCandidate &candidate)`.
        2.  Создайте несколько классов-наследников, например: `CRule_MA_Stack`, `CRule_Trend_Weakening_Conflict`.
        3.  В `CResolver` создайте массив указателей на `IRule*`.
        4.  В главном методе `Decide()` вместо `if/else` блоков пройдитесь циклом по этому массиву и примените каждое "правило" к кандидату, модифицируя его `score`.
    *   **Примечание для Cursor:** Если это слишком сложно, **минимальное требование** — просто добавить большой `TODO`-комментарий в `Decide()`:
        ```cpp
        // TODO: Refactor this logic into a Rules Engine pattern.
        // Create a base IRule class and separate rule classes (e.g., CRule_MA_Stack)
        // to make the Resolver more scalable and maintainable.
        ```
# Техническое Задание (ТЗ) для Задачи: T2-RISK - Portfolio Risk Manager (Детализированная Версия)

## 1. Цель

Создать **центральный модуль управления рисками `CRiskManager`** в файле `typ_risk.mqh`. Этот модуль должен инкапсулировать всю логику, связанную с защитой капитала, управлением экспозицией и торговой дисциплиной, в соответствии с утвержденной спецификацией.

## 2. Пошаговый План Реализации

### **Задача 1: Создание Файла и Базовой Структуры Класса**

1.  **Действие:** Создайте новый файл `Experts/TYP2/Modules/typ_risk.mqh`, если он не существует, или полностью очистите его.
2.  **Действие:** Вставьте в этот файл следующий **базовый "скелет" класса `CRiskManager`**.

    ```cpp
    // --- typ_risk.mqh ---
    #include "typ_regime_engine.mqh" // Подключаем Движок Режимов

    // --- Структура для отслеживания состояния по каждому символу ---
    struct SymbolState {
        datetime last_close_time; // Для Cooldown
        int      sl_cluster_count; // Для защиты от частых стопов
        datetime sl_cluster_start_time;
    };

    class CRiskManager {
    private:
        // --- ПАРАМЕТРЫ (будут инициализироваться из input-переменных) ---
        // EquityGuard & DailyDDCap
        double m_max_daily_dd_percent;
        bool   m_is_gradual_dd_reduction_enabled;
        // Exposure
        int    m_max_positions_per_currency;
        int    m_max_total_open_orders;
        double m_max_total_open_lots;
        double m_max_total_risk_percent;
        // Cooldown
        int    m_cooldown_seconds_win;
        int    m_cooldown_seconds_loss;
        // SL Clustering
        int    m_sl_cluster_limit;
        int    m_sl_cluster_timespan_hours;
        // EOW Protocol
        bool   m_is_eow_protocol_enabled;
        DayOfWeek m_eow_day;
        int    m_eow_hour;
        // Recovery Protocol
        bool   m_is_recovery_protocol_enabled;

        // --- СОСТОЯНИЕ КЛАССА ---
        double   m_equity_on_day_start;
        datetime m_current_day_start_time;
        bool     m_is_trading_blocked_by_dd;
        double   m_loss_for_recovery;
        // Динамический массив или карта для хранения состояния по каждому символу
        CArrayObj* m_symbol_states; // Будем использовать CMapStringToString или аналог

    public:
        // --- Публичные Методы ---
        CRiskManager();
        ~CRiskManager(); // Деструктор для очистки m_symbol_states
        void Initialize(/* ... параметры из input ... */);
        void OnTick(E_MarketRegime current_regime);
        void OnTradeClose(const string symbol, const double profit);

        // --- ФУНКЦИИ-ГВАРДЫ (для вызова перед отправкой ордера) ---
        bool CanOpenNewTrade(const string symbol, const double risk_percent, string &reason);

        // --- ВСПОМОГАТЕЛЬНЫЕ ФУНКЦИИ ---
        double CalculateLotSize(const double balance, const double risk_percent, const double sl_pips);
    
    private:
        // --- Приватные Методы-Проверки ---
        bool IsDailyDDCapOK(string &reason);
        bool IsCurrencyExposureOK(const string symbol, string &reason);
        bool IsTotalExposureOK(const double new_trade_risk_percent, string &reason);
        bool IsCooldownOK(const string symbol, string &reason);
        bool IsStopLossClusterOK(const string symbol, string &reason);
        bool IsEOWProtocolActive(string &reason);
    };
    ```

### **Задача 2: Реализация Глобальных Гвардов**

1.  **Действие:** Реализуйте метод `bool IsDailyDDCapOK(string &reason)`.
    *   **Логика:**
        1.  В `OnTick` проверяйте, начался ли новый день. Если да - обновите `m_equity_on_day_start` и сбросьте флаг `m_is_trading_blocked_by_dd`.
        2.  Рассчитайте текущую дневную просадку: `dd_percent = (m_equity_on_day_start - current_equity) / m_equity_on_day_start * 100.0`.
        3.  Если `dd_percent >= m_max_daily_dd_percent`, установите `m_is_trading_blocked_by_dd = true`.
        4.  Если `m_is_trading_blocked_by_dd` равен `true`, метод должен возвращать `false` и заполнять `reason`.
        5.  **Апгрейд "Пошаговое Снижение Риска":** Этот метод должен возвращать не `bool`, а `double` - коэффициент риска (например, `1.0` - полный риск, `0.5` - половина, `0.0` - блокировка). Если `m_is_gradual_dd_reduction_enabled == true` и `dd_percent` достиг 50% от лимита, верните `0.5`. Если 100% - верните `0.0`. В остальных случаях - `1.0`.

2.  **Действие:** Реализуйте метод `bool IsCurrencyExposureOK(const string symbol, string &reason)`.
    *   **Логика:**
        1.  Извлеките базовую валюту из `symbol` (например, `AUD` из `AUDJPY`).
        2.  Пройдитесь циклом по всем `PositionsTotal()`.
        3.  Для каждой позиции получите ее символ и извлеките базовую валюту.
        4.  Посчитайте, сколько позиций уже открыто с той же базовой валютой.
        5.  Если `count >= m_max_positions_per_currency`, верните `false` и заполните `reason`.

3.  **Действие:** Реализуйте метод `bool IsTotalExposureOK(const double new_trade_risk_percent, string &reason)`.
    *   **Логика:** Этот метод объединяет **три проверки**:
        1.  **По количеству ордеров:** `if (PositionsTotal() >= m_max_total_open_orders)` -> `false`.
        2.  **По суммарному лоту:** Посчитайте `total_lots` всех открытых позиций. `if (total_lots + new_trade_lot > m_max_total_open_lots)` -> `false`.
        3.  **По суммарному риску:** Посчитайте `total_risk_percent` всех открытых позиций (потребуется хранить риск каждой сделки при открытии). `if (total_risk_percent + new_trade_risk_percent > m_max_total_risk_percent)` -> `false`.

4.  **Действие:** Реализуйте "Протокол Конца Недели" в методе `bool IsEOWProtocolActive(string &reason)`.
    *   **Логика:**
        1.  Получите текущее серверное время `TimeCurrent()`.
        2.  Разложите его на день недели и час.
        3.  `if (m_is_eow_protocol_enabled && current_day >= m_eow_day && current_hour >= m_eow_hour)` -> `false`.
        4.  Также реализуйте логику принудительного закрытия всех позиций при наступлении этого времени.

### **Задача 3: Реализация Контекстных (посимвольных) Гвардов**

1.  **Действие:** Реализуйте `void OnTradeClose(const string symbol, const double profit)`.
    *   **Логика:** Этот метод вызывается извне после закрытия сделки.
        1.  Найдите или создайте `SymbolState` для данного `symbol`.
        2.  Обновите `last_close_time` на `TimeCurrent()`.
        3.  **Для `SL Clustering`:** Если `profit < 0` (сделка закрылась по стопу), инкрементируйте `sl_cluster_count`.

2.  **Действие:** Реализуйте `bool IsCooldownOK(const string symbol, string &reason)`.
    *   **Логика:**
        1.  Найдите `SymbolState` для данного `symbol`.
        2.  Проверьте `TimeCurrent() - state.last_close_time`.
        3.  **Апгрейд "Адаптивный Cooldown":** Используйте разные таймауты (`m_cooldown_seconds_win` / `m_cooldown_seconds_loss`) в зависимости от результата последней сделки (который нужно будет хранить в `SymbolState`).

3.  **Действие:** Реализуйте `bool IsStopLossClusterOK(const string symbol, string &reason)`.
    *   **Логика:**
        1.  Найдите `SymbolState` для данного `symbol`.
        2.  Если `TimeCurrent() - state.sl_cluster_start_time > m_sl_cluster_timespan_hours * 3600`, сбросьте счетчик `sl_cluster_count` в 0.
        3.  Если `state.sl_cluster_count >= m_sl_cluster_limit`, верните `false`.

### **Задача 4: Интеграция и Финальная Сборка**

1.  **Действие:** Реализуйте главный публичный метод `bool CanOpenNewTrade(const string symbol, const double risk_percent, string &reason)`.
    *   **Логика:** Этот метод должен **последовательно вызывать все приватные методы-проверки**. Если хотя бы одна из них возвращает `false`, он немедленно возвращает `false`, передавая `reason` от провалившейся проверки.
        ```cpp
        // Псевдокод
        double risk_modifier = IsDailyDDCapOK(reason);
        if (risk_modifier == 0.0) return false;
        
        if (!IsEOWProtocolActive(reason)) return false;
        if (!IsTotalExposureOK(risk_percent * risk_modifier, reason)) return false;
        if (!IsCurrencyExposureOK(symbol, reason)) return false;
        if (!IsCooldownOK(symbol, reason)) return false;
        if (!IsStopLossClusterOK(symbol, reason)) return false;
        
        // Если все проверки пройдены
        return true;
        ```
    *   Этот метод также должен возвращать финальный `risk_modifier` (0.5 или 1.0) для корректировки лота.

2.  **Действие:** Реализуйте интеграцию в `TakeYourProfit2.mq5` как описано в ТЗ из нашего прошлого обсуждения, но используя теперь единый метод `CanOpenNewTrade()`.